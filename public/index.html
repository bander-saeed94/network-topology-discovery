<!DOCTYPE html>
<html>
<head>
  <title>Enhanced Network Topology</title>
  <script src="/lib/vis-network/vis-network.min.js"></script>
  <link href="/lib/vis-network/vis-network.min.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    #network {
      width: 100vw;
      height: 100vh;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="network"></div>

  <script>
    function ipToInt(ip) {
      return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);
    }

    function inSameSubnet(ip1, ip2, netmask) {
      const mask = ipToInt(netmask);
      return (ipToInt(ip1) & mask) === (ipToInt(ip2) & mask);
    }

    async function loadTopology() {
      const res = await fetch('/api/topology');
      const topology = await res.json();

      const nodes = new Map();
      const edges = [];

      // Add router nodes
      topology.forEach(router => {
        nodes.set(router.routerName, {
          id: router.routerName,
          label: router.routerName,
          group: 'router',
          title: router.interfaces
            .map(i => `Interface ${i.interface}: ${i.ip} / ${i.netmask}`)
            .join('\n')
        });
      });

      // Add router-router edges (with fixes)
      topology.forEach(router => {
        router.neighborRouter.forEach(n => {
          const neighborRouter = topology.find(r =>
            r.interfaces.some(i => inSameSubnet(i.ip, n.ip, i.netmask))
          );
          if (!neighborRouter) return;

          const neighborName = neighborRouter.routerName;

          // ❌ Skip self-links
          if (router.routerName === neighborName) return;

          const thisIf = router.interfaces.find(i =>
            inSameSubnet(i.ip, n.ip, i.netmask)
          );
          const thatIf = neighborRouter.interfaces.find(i =>
            inSameSubnet(i.ip, n.ip, i.netmask)
          );

          const edgeId = [router.routerName, neighborName].sort().join('-');

          // ❌ Skip duplicate edges
          if (edges.some(e => e.id === edgeId)) return;

          edges.push({
            id: edgeId,
            from: router.routerName,
            to: neighborName,
            label: `${thisIf?.ip || '?'} ↔ ${thatIf?.ip || n.ip}`,
            font: { align: 'middle' },
            arrows: { to: { enabled: false } }
          });
        });
      });

      // Add host nodes and edges
      topology.forEach(router => {
        router.host.forEach(h => {
          const hostId = h.ip;
          if (!nodes.has(hostId)) {
            nodes.set(hostId, {
              id: hostId,
              label: h.ip,
              group: 'host'
            });
          }

          const matchedInterface = router.interfaces.find(i =>
            inSameSubnet(i.ip, h.ip, i.netmask)
          );

          edges.push({
            from: router.routerName,
            to: hostId,
            label: matchedInterface ? `via ${matchedInterface.ip}` : '',
            font: { align: 'top' }
          });
        });
      });

      const data = {
        nodes: Array.from(nodes.values()),
        edges: edges
      };

      const options = {
        groups: {
          router: { shape: 'box', color: '#ADD8E6' },
          host: { shape: 'ellipse', color: '#FFDD99' }
        },
        layout: {
          hierarchical: {
            enabled: true,
            direction: 'LR',
            sortMethod: 'hubsize'
          }
        },
        physics: false,
        interaction: {
          hover: true,
          tooltipDelay: 100
        }
      };

      const container = document.getElementById('network');
      new vis.Network(container, data, options);
    }

    // Load on start and refresh every 15 minutes
    loadTopology();
    setInterval(loadTopology, 15  * 1000);
  </script>
</body>
</html>
